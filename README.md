# n42-43
Анна

1-Стек (англ. stack стопка) это линейный список, в котором элементы добавляются и удаляются только с одного конца (англ. LIFO: Last In - First Out- последний пришёл первым ушёл)

2-Cтек используется при выполнении программ: в нём хранятся адреса возврата из подпрограмм, параметры, передаваемые функциям и процедурам, а также локальные переменные

3-Принято выделять два вида ошибок в стеке: 

1) (pop) удаление значения из пустого стека (опустошение);

2) (push) добавление элемента в переполненный стек (переполнение)

4-Обычный массив можно использовать для моделирования стека, когда заранее известно, сколько элементов будет в этой структуре

5-для создания стека в программе мы можем использовать динамический массив

6-При передаче стека в подпрограммы (например, через параметры функции), необходимо, чтобы соответствующий параметр был изменяемым

7-Очередь это линейный список, для которого введены две операции:

-  добавление нового элемента в конец очереди;

- удаление первого элемента из очереди

8-Обработка запросов в многозадачной операционной системе, печать нескольких документов одновременно, отслеживание порядка в очереди

#43

1-дерево это структура, отражающая иерархию (отношения подчинённости, многоуровне вые связи). Напомним некоторые основные понятия, связанныес деревьями. Дерево состоит из узлов и связей между ними (они называются дугами). Самый первый узел, расположенный на верхнем уровне (в него не входит ни одна стрелка-дуга), это корень дерева. Конечные узлы, из которых не выходит ни одна дуга, называются листьями. 
Все остальные узлы, кроме корня и листьев, это промежуточные узлы. Из двух связанных узлов тот, который находится на более высоком уровне, называется родителем, а другой сыном. Корень это единственный узел, у которого нет родителя; у листьев нет сыновей.
Используются также понятия «предок» и «потомок». Потомок какого-то узла это узел, в который можно перейти по стрелкам от узла-предка. Соответствен-но, предок какого-то узла это узел, из которого можно перейти по стрелкам в данный узел. Высота дерева это наибольшее расстояние (количество дуг) от корня до листа

2-Структуры типа «дерево» в информатике используются в следующих областях:

- Управление иерархией данных;

- Упрощение поиска информации;

- Управление сортированными списками данных;

- Синтаксический разбор арифметических выражений;

- Оптимизация программ;

- т.д.

3-Деревья, также как и списки, являются рекурсивным типом данных. Дерево – это структура данных, которая может быть разделена на корень дерева, левое и правое поддеревья. Так как левое и правое поддеревья в свою очередь являются деревьями, структура рекурсивна. Кроме того, дерево является еще и составным объектом данных

4-Нет, линейный список нельзя считать частным случаем дерева. Это объясняется тем, что у дерева может быть больше двух соседей, в то время как в линейном списке для каждого элемента, кроме первого, есть предыдущий элемент, а для каждого элемента, кроме последнего, — следующий элемент

5-Бинарное дерево поиска — это бинарное дерево, обладающее дополнительными свойствами: значение левого потомка меньше значения родителя, а значение правого потомка больше значения родителя для каждого узла дерева

6-Чтобы построить дерево поиска из массива данных, нужно следовать таким правилам: 

- Ни один элемент не может иметь более двух потомков; 

- В левом поддереве необходимо располагать все значения меньше значения данного элемента, а в правом — все значения больше него

7-Иерархическая структура, эффективные операции поиска, вставки и удаления, упорядоченная структура, поддержка рекурсивных алгоритмов, гибкость в использовании

8-Пошаговый перебор элементов дерева по связям между узлами-предками и узлами-потомками называется обходом дерева

9-Прямой обход, симметричный обход, обратный обход, т.д.

10-Дерево начинает строиться с терма E (expression). Его можно заменить на одно из трех выражений (разделённых вертикальной чертой) из первой строки, например на: T1 + E. Затем необходимо сделать две замены для T1 и E, например (T2*T1) + T1. Далее, (T3*T2) + T2 и т.д.

11-Деревья в программе на Паскале можно представить массивами или связными структурами динамических объектов

12-В двоичных деревьях, где у каждого узла может быть не более двух сыновей, чтобы указать, что у узла нет левого или правого сына, используют поля с указателями на сыновей, которые равны nullptr

13-Память под новый узел выделяется динамически во время работы программы

14-Рекурсивные алгоритмы работы с деревьями могут быть проще нерекурсивных, потому что в рекурсивных функциях нужно заботиться только об узле, при этом они используют стек для хранения состояния для каждого вызова

15-Для хранения двоичного дерева в массиве можно использовать следующий алгоритм:

Сохранить корневой узел в позиции 0. 

Для каждого узла с индексом i его дочерние элементы разместить в позициях с индексами (i * 2) + 1 и (i * 2) + 2.

Если индекс любого дочернего узла больше, чем длина массива — 1, то у этого узла нет дочерних узлов.

Для деревьев, в которых узлы могут иметь больше двух сыновей, такой приём использовать нельзя, так как двоичное дерево имеет ограничение на количество дочерних узлов — не более двух. Если это правило нарушается, то дерево перестаёт относиться к классу бинарных
